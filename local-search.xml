<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习基础01 | 成本函数</title>
    <link href="/2021/07/06/7-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/07/06/7-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="名词与变量的定义"><a href="#名词与变量的定义" class="headerlink" title="名词与变量的定义"></a>名词与变量的定义</h3><p><strong>Training Set</strong> 训练集 - 提供给算法进行学习的数据集合</p><p>M - 训练集中包含的样本 examples 总数</p><p>x’s - 输入变量 / 特征值</p><p>y’s - 输出变量 / 目标变量</p><script type="math/tex; mode=display">( x \, , \, y )$$ - 表示单个的训练样本$$( x ^ { ( i ) } \, , \, y ^ { ( i ) } )$$ - 具体的第 i 个训练样本**Hypothesis / h** 假设 - 即一个函数，当输入 x 的数值时，将输出一个预测值### 机器学习的总体逻辑<pre><code class=" mermaid">graph LRA(Training Set) --&gt; B(Learning Algorithm)B --&gt; C&#123;h&#125;D((x)) --&gt; CC --&gt; E((predicted y))</code></pre>预测的 y 值越接近训练集中的 y 值，则模型的预测效果越好## 单变量线性回归模型### 定义假设在单变量线性回归模型中，只有 1 个变量 x ，包括两个参数 θ0 和 θ1</script><p>h _ \theta ( x ) = \theta _ 0 + \theta _ 1 x</p><script type="math/tex; mode=display">机器学习的目标是使得两个参数尽可能小，以使预测值尽可能接近 y ，数学表示如下：</script><p>J \left( \theta_0,\theta_1 \right) = \frac 1 {2m} \sum ^m _{i=1} \left( \widehat y_i - y _i \right)^2 = \frac 1 {2m} \sum ^m _{i=1} \left( h_\theta (x^{(i)}) - y^{(i)} \right)^2 = \frac 1 {2m} \sum ^m _{i=1} \left(  \theta _ 0 + \theta _ 1 x - y^{(i)} \right)^2 \; , \; \underset{\theta_0,\theta_1}{minimize}</p><script type="math/tex; mode=display">这一公式又被称为成本函数 cost function ，或者方差函数 Square Error Function### 简化版的使用方法在初阶的使用方法中，不考虑参数 θ0 ，而只考虑影响直线斜率的 θ1 ，函数图像始终穿过原点假设训练集包括 3 个样本： ( 1 , 1 )  /  ( 2 , 2 )  /  ( 3 , 3 ) ，用成本函数尝试拟合目标：求  J 函数取得最小值时，θ1 的取值当 θ1 = 1 时，函数为 h(x) = x ，x 在 3 个取值处分别得到 1 / 2 / 3 这 3 个预测值，可得 J(1) = 0</script><p>J \left( 1 \right) = \frac 1 {2 \times 3} \sum ^3 _{i=1} \left( x - y^{(i)} \right)^2 = \frac 1 6 \left( 0^2+0^2+0^2 \right) = 0 \; , \; ( m = 3,\theta_1 = 1 )</p><script type="math/tex; mode=display">同理，当 θ1 = 0.5 时，函数为 h(x) = 0.5x ，x 在 3 个取值处分别得到 0.5 / 1 / 1.5 这 3 个预测值，可得 J(0.5) ≈ 0.58</script><p>J \left( 0.5 \right) = \frac 1 6 \left( 0.5^2+1^2+1.5^2 \right) = \frac {3.5} 6 \approx 0.58 \; , \; ( m = 3,\theta_1 = 0.5 )</p><p>$$</p><p>用同样的计算过程计算 θ1 = 0 / 1.5 / 2 / 2.5 … 处的数值，形成 J 函数的正 U 型曲线图像，易得 θ1 的最小值出现在 1 处，其数值为 0</p><p>即：当 θ1 取值为 1 时，J 函数取得最小值，算法取得了最优的预测效果</p><p><em>未完待续…</em></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Machine Learining Lectures by Andrew Ng in Stanford University. Site : <a href="https://www.coursera.org/learn/machine-learning/home/welcome">机器学习 | Coursera</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCI概念解析：混淆矩阵</title>
    <link href="/2021/05/27/6-%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/05/27/6-%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-分类模型"><a href="#1-分类模型" class="headerlink" title="1 分类模型"></a>1 分类模型</h2><h3 id="1-1-概念阐释"><a href="#1-1-概念阐释" class="headerlink" title="1.1 概念阐释"></a>1.1 概念阐释</h3><p>分类模型：机器学习领域的概念，机器在现有数据中进行学习与训练，从而形成预测新数据类别变量的能力</p><p>分类任务：找到一个函数，把观测值匹配到相关的类和标签上</p><p><strong>[ 对比 ]</strong> 回归模型：预测数值型变量</p><h3 id="1-2-公式阐释"><a href="#1-2-公式阐释" class="headerlink" title="1.2 公式阐释"></a>1.2 公式阐释</h3><p>给定训练数据<img src="https://private.codecogs.com/gif.latex?D%3D%7B%5Cleft%20%5C%7B%20x_i%2Cy_i%5Cright%20%5C%7D%7D%5EN_i" alt="D={\left \{ x_i,y_i\right \}}^N_i"></p><p>分类任务将学习一个从输入 <script type="math/tex">x</script> 到输出 <script type="math/tex">y</script> 的映射 <script type="math/tex">f</script> ：</p><p><img src="https://private.codecogs.com/gif.latex?%5Chat%7By%7D%20%3D%20f%28x%29%3Dargmaxp%28y%3Dc%7Cx%2CD%29" alt="\hat{y} = f(x)=argmaxp(y=c \mid x,D)">【最大后验估计】</p><p>其中，<script type="math/tex">y</script> 为离散值，其值范围为标签空间：<img src="https://private.codecogs.com/gif.latex?Y%3D%5Cleft%20%5C%7B%201%2C2%2C...%2CC%20%5Cright%20%5C%7D" alt="Y=\left \{ 1,2,...,C \right \}"></p><p><script type="math/tex">y=c \mid x</script> 是贝叶斯定理中的后验概率公式</p><h2 id="2-二元分类问题混淆矩阵结构"><a href="#2-二元分类问题混淆矩阵结构" class="headerlink" title="2 二元分类问题混淆矩阵结构"></a>2 二元分类问题混淆矩阵结构</h2><h3 id="2-1-混淆矩阵的概念与构成"><a href="#2-1-混淆矩阵的概念与构成" class="headerlink" title="2.1 混淆矩阵的概念与构成"></a>2.1 混淆矩阵的概念与构成</h3><p><strong>混淆矩阵 [ Confusion Matrix ]</strong> 是数据科学、数据分析和机器学习中总结分类模型预测结果的情形分析表，以矩阵形式将数据进行集中记录，按照 <strong>真实的类别</strong> 与 <strong>分类模型作出的分类判断</strong> 两个标准进行汇总</p><p>混淆矩阵的每一列代表了 <strong>预测类别</strong> ，每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的 <strong>真实归属类别</strong> ，每一行的数据总数表示该类别的数据实例的数目</p><h3 id="2-2-二元分类问题下的混淆矩阵"><a href="#2-2-二元分类问题下的混淆矩阵" class="headerlink" title="2.2 二元分类问题下的混淆矩阵"></a>2.2 二元分类问题下的混淆矩阵</h3><p>二元分类问题：数据集存在肯定类别和否定类别两类记录，而分类模型对记录分类可能作出阳性判断（判断记录属于肯定类别）或阴性判断（判断记录属于否定类别）两种判断</p><p>二元分类问题的混淆矩阵是一个 2  ×  2 的情形分析表，呈现以下 4 组记录的数目：</p><ul><li>作出正确判断的肯定记录 - 真阳性 TP</li><li>作出错误判断的肯定记录 - 假阴性 FN</li><li>作出正确判断的否定记录 - 真阴性 TN</li><li>作出错误判断的否定记录 - 假阳性 FP</li></ul><p><img src="https://pic1.zhimg.com/80/v2-026440fdfe0a0a799a135cc534cb61e2_720w.jpg?source=1940ef5c" alt="img"></p><p>以及附上一张通俗易懂的帮助理解的趣图：</p><p><img src="https://pic2.zhimg.com/80/v2-59689b1fec1f8be953696fc2ad9fc397_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="2-3-举个栗子"><a href="#2-3-举个栗子" class="headerlink" title="2.3 举个栗子"></a>2.3 举个栗子</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Predicted class  \  Actual class</th><th style="text-align:center">Cat</th><th style="text-align:center">Dog</th></tr></thead><tbody><tr><td style="text-align:center">Cat</td><td style="text-align:center"><strong>6</strong></td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Dog</td><td style="text-align:center">1</td><td style="text-align:center"><strong>3</strong></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">Predicted class  \  Actual class</th><th style="text-align:center">P</th><th style="text-align:center">N</th></tr></thead><tbody><tr><td style="text-align:center">P</td><td style="text-align:center"><strong>TP</strong></td><td style="text-align:center">FN</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">FP</td><td style="text-align:center"><strong>TN</strong></td></tr></tbody></table></div><h3 id="2-3-可直接推出的数值"><a href="#2-3-可直接推出的数值" class="headerlink" title="2.3 可直接推出的数值"></a>2.3 可直接推出的数值</h3><h4 id="2-3-1-关于真实数据本身"><a href="#2-3-1-关于真实数据本身" class="headerlink" title="2.3.1 关于真实数据本身"></a>2.3.1 关于真实数据本身</h4><p>数据集中的记录总数 = TP + FP + FN + TN</p><p>数据集中的肯定记录数 = TP + FN</p><p>数据集中的否定记录数 = FP + TN</p><h4 id="2-3-2-关于计算机的分类模型"><a href="#2-3-2-关于计算机的分类模型" class="headerlink" title="2.3.2 关于计算机的分类模型"></a>2.3.2 关于计算机的分类模型</h4><p>分类模型作出阳性判断的记录数 = TP + FP</p><p>分类模型作出阴性判断的记录数 = FN + TN</p><p>分类模型作出正确分类的记录数 = TP + TN</p><p>分类模型作出错误分类的记录数 = FP + FN</p><h3 id="2-4-推导的其他度量值"><a href="#2-4-推导的其他度量值" class="headerlink" title="2.4 推导的其他度量值"></a>2.4 推导的其他度量值</h3><p><strong>准确率 Accuracy</strong> = ( TP + TN ) / ( TP + TN + FN + TN )</p><blockquote><p>表示总样本中预测对了多少</p></blockquote><p><strong>精确率 Precision / PPV - positive predictive value</strong> = TP / ( TP + FP )</p><blockquote><p>判断为正的样本中，实际为正的比例</p></blockquote><p><strong>召回率 查全率 Recall / 灵敏度 Sensitivity / 真阳性率 TPR True Positive Rate</strong> = TP / ( TP + FN )</p><blockquote><p>实际为正的样本中，判断为正的比例</p><p>可以作为避免 <strong>假阴性</strong> 的量化指标</p></blockquote><p><strong>特异度 Specificity / 真阴性率 TNR True Negative Rate</strong> = TN / ( TN + FP )</p><blockquote><p>实际为阴性的样本中，判断为阴性的比例</p><p>可以作为避免 <strong>假阳性</strong> 的量化指标</p></blockquote><p><strong>F1得分 F1-score</strong> = 2 × TP / ( 2 × TP + FP + FN ) </p><blockquote><p>是精确率和召回率的调和平均数</p></blockquote><p>公式大全：<a href="https://en.wikipedia.org/wiki/Confusion_matrix">Confusion matrix - Wikipedia</a></p><h2 id="3-分类器的真实性能"><a href="#3-分类器的真实性能" class="headerlink" title="3 分类器的真实性能"></a>3 分类器的真实性能</h2><h3 id="3-1-准确度-×"><a href="#3-1-准确度-×" class="headerlink" title="3.1 准确度 ×"></a>3.1 准确度 ×</h3><p>对于分类器的真实性能，准确性不是可靠的指标，因为如果数据集不平衡（即当不同类别中的观察数具有很大差异时，比如A类95个、B类5个），只看准确性数值将产生误导性结果</p><p>在这种情况下，F1得分甚至更加不可靠</p><h3 id="3-2-约登公式-√"><a href="#3-2-约登公式-√" class="headerlink" title="3.2 约登公式 √"></a>3.2 约登公式 √</h3><p>约登指数消除了这种偏见，并且将0作为乱猜情况下能增加信息量的决定（英语：informed decision）的概率</p><p>约登指数为0的系统或测试不具有任何作用</p><p><strong>约登指数 J</strong> = 灵敏度 + 特异度 − 1</p><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_27344959/article/details/82824401">机器学习分类模型_- 如风飘荡的男子的博客</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.zhihu.com/question/36883196">混淆矩阵是什么意思 - 知乎</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://zh.wikipedia.org/wiki/混淆矩阵">混淆矩阵 - 维基百科</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://baike.baidu.com/item/混淆矩阵">混淆矩阵 -_百度百科</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="http://sofasofa.io/forum_main_post.php?postid=1000597">什么是混淆矩阵(confusion matrix)-SofaSofa</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://zh.wikipedia.org/wiki/约登指数">约登指数 - 维基百科</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>一个计算混淆矩阵数据的API：<a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html">sklearn.metrics.confusion_matrix</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>一个简明易懂的教程：<a href="https://www.bilibili.com/video/BV1SJ411x7jH?from=search&amp;seid=12978593607876465063">【机器学习】五分钟搞懂如何评价二分类模型 -_bilibili</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>HCI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人机交互</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率统计基础</title>
    <link href="/2021/05/07/5-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86/"/>
    <url>/2021/05/07/5-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-随机事件"><a href="#1-随机事件" class="headerlink" title="1 随机事件"></a>1 随机事件</h2><h3 id="1-1-随机试验"><a href="#1-1-随机试验" class="headerlink" title="1.1 随机试验"></a>1.1 随机试验</h3><p>试验定义：对随机现象加以研究所进行的观察或实验</p><p>随机试验：满足三大特点<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="韩旭里, 谢永钦.概率论与数理统计[M].北京大学出版社:北京,2018:02-25.">[1]</span></a></sup>的试验，记为 <script type="math/tex">E</script></p><ul><li>可以在相同条件下重复进行</li><li>每次试验的结果可能不止一个，并且事先可以明确试验所有可能出现的结果</li><li>进行一次试验之前不能确定哪个结果会出现</li></ul><h3 id="1-2-基本结果-样本点-样本空间"><a href="#1-2-基本结果-样本点-样本空间" class="headerlink" title="1.2 基本结果 / 样本点 / 样本空间"></a>1.2 基本结果 / 样本点 / 样本空间</h3><p>基本结果：</p><ul><li>任何结果，都是由其中一些基本结果构成</li><li>每进行一次试验，必然出现且只能出现其中一个基本结果</li></ul><p>样本点：随机试验 <script type="math/tex">E</script> 的每个基本结果，记作 <script type="math/tex">\omega_i</script> </p><p>样本空间：由随机试验 <script type="math/tex">E</script> 所有基本结果组成的集合，记为 <script type="math/tex">\Omega</script> ， <script type="math/tex">\Omega = \{ \omega_1,\omega_2,...,\omega_n,... \}</script></p><h3 id="1-3-事件"><a href="#1-3-事件" class="headerlink" title="1.3 事件"></a>1.3 事件</h3><p>随机事件：随机试验 <script type="math/tex">E</script> 的样本空间 <script type="math/tex">\Omega</script> 的子集，简称事件</p><p>每次试验中当且仅当这一子集中的一个样本点出现时，称这一事件发生</p><p>必然事件：每次试验中都必然发生的事件，也用 <script type="math/tex">\Omega</script> 表示</p><p>不可能事件：每次试验中不可能发生的事件，用空集 <script type="math/tex">\varnothing</script> 表示</p><h3 id="1-4-事件关系"><a href="#1-4-事件关系" class="headerlink" title="1.4 事件关系"></a>1.4 事件关系</h3><h4 id="1-4-1-包含于"><a href="#1-4-1-包含于" class="headerlink" title="1.4.1 包含于"></a>1.4.1 包含于</h4><p>如果事件 <script type="math/tex">A</script> 发生必然导致事件 <script type="math/tex">B</script> 发生，则事件 <script type="math/tex">A</script> 包含于事件 <script type="math/tex">B</script> ，或事件 <script type="math/tex">B</script> 包含事件 <script type="math/tex">A</script> ，记为 <script type="math/tex">A \subset B</script> 或 <script type="math/tex">B \supset A</script></p><p>如果事件 <script type="math/tex">B</script> 不发生，则事件 <script type="math/tex">A</script> 必然不发生</p><p>如果 <script type="math/tex">A \subset B</script> 且 <script type="math/tex">B \subset A</script> ，则事件 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 相等，记为 <script type="math/tex">A = B</script></p><p>对于任一事件 <script type="math/tex">A</script> ，有 <script type="math/tex">\varnothing \subset A</script> ，<script type="math/tex">A \subset \Omega</script></p><h4 id="1-4-2-并"><a href="#1-4-2-并" class="headerlink" title="1.4.2 并"></a>1.4.2 并</h4><p>事件 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 中至少有一个发生的事件，称为 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 的并（和），记为 <script type="math/tex">A \cup B</script></p><ul><li><script type="math/tex; mode=display">A \cup \Omega = \Omega \; ; \; A \cup \varnothing = A</script></li><li><script type="math/tex">A = \bigcup _ {i=1} ^ n A_i</script> 表示事件 <script type="math/tex">A_1,A_2,...,A_n</script> 中至少有一个发生 </li><li><script type="math/tex">A = \bigcup _ {i=1} ^ \infty A_i</script> 表示可数无穷多个事件 <script type="math/tex">A_i</script> 中至少有一个发生</li></ul><blockquote><p>有限：空集、整数集 {1, … , n}</p><p>无穷：自然数集</p><p>可数（无穷）：有理数集、代数集</p><p>不可数：实数集</p></blockquote><h4 id="1-4-3-交"><a href="#1-4-3-交" class="headerlink" title="1.4.3 交"></a>1.4.3 交</h4><p>事件 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 同时发生，称为 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 的交（积），记为 <script type="math/tex">A \cap B</script> 或 <script type="math/tex">AB</script> </p><ul><li><p>对于任一事件 <script type="math/tex">A</script> ，有 <script type="math/tex">A \cap \varnothing = \varnothing \; , \; A \cap \Omega = A</script> </p></li><li><p><script type="math/tex">B = \bigcap _ {i=1} ^ n B_i</script> 表示事件 <script type="math/tex">B_1,B_2,...,B_n</script> 这 $n$ 个事件同时发生</p></li><li><p><script type="math/tex">B = \bigcap _ {i=1} ^ \infty B_i</script> 表示可数无穷多个事件 <script type="math/tex">B_i</script> 同时发生</p></li></ul><h4 id="1-4-4-差"><a href="#1-4-4-差" class="headerlink" title="1.4.4 差"></a>1.4.4 差</h4><p>事件 <script type="math/tex">A</script> 发生而事件 <script type="math/tex">B</script> 不发生，称为 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 的差，记为 <script type="math/tex">A-B</script></p><ul><li><script type="math/tex; mode=display">A - A = \varnothing</script></li><li><script type="math/tex; mode=display">A - \varnothing = A</script></li><li><script type="math/tex; mode=display">A - \Omega = \varnothing</script></li></ul><h4 id="1-4-5-互不相容"><a href="#1-4-5-互不相容" class="headerlink" title="1.4.5 互不相容"></a>1.4.5 互不相容</h4><p>两个事件 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 不可能同时发生，则称事件 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 为互不相容（互斥），记为 <script type="math/tex">A \cap B = \varnothing</script> </p><p>基本事件之间两两互不相容</p><h4 id="1-4-6-对立事件"><a href="#1-4-6-对立事件" class="headerlink" title="1.4.6 对立事件"></a>1.4.6 对立事件</h4><p>如果 <script type="math/tex">A \cup B = \Omega</script> 且 <script type="math/tex">A \cap B = \varnothing</script> ，则称事件 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 互为逆事件（对立事件），<script type="math/tex">A</script> 的对立事件记为 <script type="math/tex">\overline A</script> ，<script type="math/tex">\overline A</script> 由所有不属于 <script type="math/tex">A</script> 的样本点组成</p><script type="math/tex; mode=display">\overline A = \Omega - A$$ ；$$\overline { \overline A } = A</script><p>对立事件必是互不相容事件，而互不相容事件未必是对立事件</p><h3 id="1-5-事件间的运算律"><a href="#1-5-事件间的运算律" class="headerlink" title="1.5 事件间的运算律"></a>1.5 事件间的运算律</h3><p><strong>交换律：</strong> </p><script type="math/tex; mode=display">A \cup B = B \cup A</script><script type="math/tex; mode=display">A \cap B = B \cap A</script><p><strong>结合律：</strong></p><script type="math/tex; mode=display">A \cup ( B \cup C ) = ( A \cup B ) \cup CA \cup ( B \cup C ) = ( A \cup B ) \cup CA \cup ( B \cup C ) = ( A \cup B ) \cup C</script><script type="math/tex; mode=display">A \cap ( B \cap C ) = ( A \cap B ) \cap C</script><p><strong>分配律：</strong></p><script type="math/tex; mode=display">A \cup ( B \cap C ) = ( A \cup B ) \cap ( A \cup C )A \cup ( B \cap C ) = ( A \cup B ) \cap ( A \cup C )</script><script type="math/tex; mode=display">A \cap ( B \cup C ) = ( A \cap B ) \cup ( A \cap C )A \cap ( B \cup C ) = ( A \cap B ) \cup ( A \cap C )</script><script type="math/tex; mode=display">A \cap \left( \bigcup _{i=1} ^ n A _ i \right) = \bigcup _{i=1} ^ n ( A \cap A _ i)</script><script type="math/tex; mode=display">A \cup \left( \bigcap _{i=1} ^ n A _ i \right) = \bigcap _{i=1} ^ n ( A \cup A _ i)</script><script type="math/tex; mode=display">A \cap \left( \bigcup _ { i = 1 } ^ \infty A _ i \right) = \bigcup _{i=1} ^ \infty ( A \cap A _ i)</script><script type="math/tex; mode=display">A \cup \left( \bigcap _{i=1} ^ \infty A _ i \right) = \bigcap _{i=1} ^ \infty ( A \cup A _ i)</script><p><strong>对立事件运算：</strong></p><script type="math/tex; mode=display">A - B = A \overline B = A - AB</script><p><strong>对有穷或可数无穷个事件</strong> $A_i$ <strong>，恒有：</strong></p><script type="math/tex; mode=display">\overline { \bigcup _{i=1} ^ n A _ i} = \bigcap _{i=1} ^ n \overline {A _ i}</script><script type="math/tex; mode=display">\overline {\bigcap _{i=1} ^ n A _ i} = \bigcup _{i=1} ^ n \overline {A _ i}</script><script type="math/tex; mode=display">\overline { \bigcup _{i=1} ^ \infty A _ i } = \bigcap _{i=1} ^ \infty \overline {A _ i}</script><script type="math/tex; mode=display">\overline { \bigcap _{ i = 1 } ^ \infty A _ i } = \bigcup _ { i = 1 } ^ \infty \overline { A _ i }</script><h2 id="2-概率"><a href="#2-概率" class="headerlink" title="2 概率"></a>2 概率</h2><h3 id="2-1-频率"><a href="#2-1-频率" class="headerlink" title="2.1 频率"></a>2.1 频率</h3><p>在相同条件下进行了 <script type="math/tex">n</script> 次试验，若随机事件 $A$ 在 <script type="math/tex">n</script> 次实验中发生了 $k$ 次，则比值 <script type="math/tex">\frac k n</script> 称为事件 $A$ 在这 <script type="math/tex">n</script> 次试验中发生的频率<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="韩旭里, 谢永钦.概率论与数理统计[M].北京大学出版社:北京,2018:02-25.">[1]</span></a></sup>，记为：</p><script type="math/tex; mode=display">f _ n ( A ) = \frac k n</script><p>对于任一事件 <script type="math/tex">A</script> ，有 <script type="math/tex">0 \leqslant f _ n ( A ) \leqslant 1</script></p><p>对于必然事件 <script type="math/tex">\Omega</script> ，有 <script type="math/tex">f _ n ( \Omega ) = 1</script></p><p>若事件 <script type="math/tex">A \; , \; B</script> 互不相容，则：<script type="math/tex">f _ n ( A \cup B ) = f _ n ( A ) + f _ n ( B )</script></p><p>若事件 <script type="math/tex">A_1 , A_2 , ... , A_m</script> 两两互不相容，则：</p><script type="math/tex; mode=display">f _ n \left( \bigcup _ { i = 1 } ^ m A _ i \right) = \sum _ { i = 1 } ^ m f _ n ( A _ i )</script><h3 id="2-2-概率的统计定义"><a href="#2-2-概率的统计定义" class="headerlink" title="2.2 概率的统计定义"></a>2.2 概率的统计定义</h3><p>设事件 <script type="math/tex">A</script> 在 <script type="math/tex">n</script> 次重复试验中发生的次数为 <script type="math/tex">k</script> ，当 <script type="math/tex">n</script> 很大时，频率 <script type="math/tex">\frac k n</script> 在某一数值 <script type="math/tex">p</script> 的附近摆动</p><p>随着试验次数 <script type="math/tex">n</script> 的增加，发生较大摆动的可能性越来越小<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="韩旭里, 谢永钦.概率论与数理统计[M].北京大学出版社:北京,2018:02-25.">[1]</span></a></sup>，则将数值 <script type="math/tex">p</script> 称为事件 <script type="math/tex">A</script> 发生的概率，记为 <script type="math/tex">P ( A ) = p</script></p><h3 id="2-3-概率的公理化定义"><a href="#2-3-概率的公理化定义" class="headerlink" title="2.3 概率的公理化定义"></a>2.3 概率的公理化定义</h3><p>设 <script type="math/tex">\Omega</script> 为样本空间，<script type="math/tex">A</script> 为事件，对于每一个事件 <script type="math/tex">A</script> 赋予一个实数作为事件 <script type="math/tex">A</script> 的概率，记为 <script type="math/tex">P(A)</script> ，其满足下列条件<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="韩旭里, 谢永钦.概率论与数理统计[M].北京大学出版社:北京,2018:02-25.">[1]</span></a></sup>：</p><ul><li>非负性：<script type="math/tex">P(A) \geqslant 0</script></li><li>规范性：<script type="math/tex">P(\Omega) = 1</script></li><li>可数可加性：对于两两互不相容的可数无穷多个事件 <script type="math/tex">A_1 , A_2 , ... , A_n , ...</script> ，有</li></ul><script type="math/tex; mode=display">P ( \bigcup _ { n = 1 } ^ \infty A _ n ) = \sum _ { n = 1 } ^ \infty P ( A _ n )</script><p>当 <script type="math/tex">n \to \infty</script> ，频率 <script type="math/tex">f _ n ( A )</script> 在一定意义上接近于概率 <script type="math/tex">P(A)</script> </p><h3 id="2-4-概率的性质"><a href="#2-4-概率的性质" class="headerlink" title="2.4 概率的性质"></a>2.4 概率的性质</h3><p>不可能事件的概率为 0 ，<script type="math/tex">P(\varnothing) = 0</script></p><p>有限可加性：</p><script type="math/tex; mode=display">P ( \bigcup _ { k = 1 } ^ n A _ k ) = \sum _ { k = 1 } ^ n P ( A _ k )</script><p>设 <script type="math/tex">A,B</script> 是两个事件，则有：<script type="math/tex">P(B-A) = P(B) - P(AB)</script></p><p>设 <script type="math/tex">A,B</script> 是两个事件，若  <script type="math/tex">A \subset B</script> ，则有：<script type="math/tex">P(B-A) = P(B) - P(A) \: ; \: P(A) \leqslant P(B)</script></p><p>对于任一事件 <script type="math/tex">A</script> ，有 <script type="math/tex">P(A) \leqslant 1</script></p><p>对于任一事件 <script type="math/tex">B</script> ，有 <script type="math/tex">P( \overline A ) = 1 - P(A)</script></p><p><strong>[ 加法公式 ]</strong> 对于任意两个事件 <script type="math/tex">A,B</script> ，有：<script type="math/tex">P(A \cup B) = P(A) + P(B) - P(AB)</script></p><p><strong>[ 加法公式的推广 ]</strong> </p><p>对于任意三个事件 <script type="math/tex">A_1,A_2,A_3</script> ，有：</p><script type="math/tex; mode=display">P(A_1 \cup A_2 \cup A_3) = P(A_1) + P(A_2) + P(A_3) - P(A_1A_2) - P(A_1A_3) - P(A_2A_3) + P(A_1A_2A_3)​</script><p>对于任意 <script type="math/tex">n</script> 个事件：</p><script type="math/tex; mode=display">P(A_1 \cup A_2 \cup ... \cup A_n) = \sum _ {i=1} ^ n P(A_i) - \sum _ {1 \leqslant i < j \leqslant n} P(A_iA_j) + \sum _ {1 \leqslant i < j < k \leqslant n} P(A_iA_jA_k) - ... + (-1) ^ { n - 1 } P(A_1A_2...A_n)</script><h3 id="2-5-古典概型-等可能概型"><a href="#2-5-古典概型-等可能概型" class="headerlink" title="2.5 古典概型 / 等可能概型"></a>2.5 古典概型 / 等可能概型</h3><h4 id="2-5-1-满足条件"><a href="#2-5-1-满足条件" class="headerlink" title="2.5.1 满足条件"></a>2.5.1 满足条件</h4><p>试验的样本空间 <script type="math/tex">\Omega</script> 只有有限个样本点，即：<script type="math/tex">\Omega = \{ \omega_1 , \omega_2 , ... , \omega_n \}</script></p><p>试验中的每个基本事件的发生是等可能的，即：<script type="math/tex">P( \{ \omega_1 \} ) = P( \{ \omega_2 \} ) = ... = P( \{ \omega_n \} )</script></p><h4 id="2-5-2-古典概率计算公式"><a href="#2-5-2-古典概率计算公式" class="headerlink" title="2.5.2 古典概率计算公式"></a>2.5.2 古典概率计算公式</h4><script type="math/tex; mode=display">P(A) = \frac k n = \frac { A所包含的样本点数 } { \Omega 中的样本点总数 }</script><p>一般利用排列组合及乘法原理、加法原理计算 <script type="math/tex">k</script> 与 <script type="math/tex">n</script> ，进而求得概率<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="韩旭里, 谢永钦.概率论与数理统计[M].北京大学出版社:北京,2018:02-25.">[1]</span></a></sup></p><h3 id="2-6-几何概型"><a href="#2-6-几何概型" class="headerlink" title="2.6 几何概型"></a>2.6 几何概型</h3><p>将古典概型推广到试验结果无穷多的情况，此时：</p><ul><li>样本空间 <script type="math/tex">\Omega</script> 是一个几何区域，区域大小可以度量（长度、面积、体积等），将 <script type="math/tex">\Omega</script> 的度量记为 <script type="math/tex">m(\Omega)</script></li><li>向区域 <script type="math/tex">\Omega</script> 内任意投掷一个点，该点落在区域内任一点处都是等可能的</li><li>落在 <script type="math/tex">\Omega</script> 中的区域 <script type="math/tex">A</script> 内的可能性与 <script type="math/tex">A</script> 的度量 <script type="math/tex">m(A)</script> 成正比，与 <script type="math/tex">A</script> 的位置和形状无关</li></ul><script type="math/tex; mode=display">P(A) = \frac { m(A) } { m(\Omega) }</script><h2 id="3-条件概率与全概率"><a href="#3-条件概率与全概率" class="headerlink" title="3 条件概率与全概率"></a>3 条件概率与全概率</h2><h3 id="3-1-条件概率定义"><a href="#3-1-条件概率定义" class="headerlink" title="3.1 条件概率定义"></a>3.1 条件概率定义</h3><p>设 <script type="math/tex">A,B</script> 为两个事件，且 <script type="math/tex">P(B) > 0</script> ，则事件 <script type="math/tex">B</script> 已发生的条件下事件 <script type="math/tex">A</script> 发生的条件概率公式为：</p><script type="math/tex; mode=display">P(A \mid B) = \frac { P(AB) } { P(B) }</script><p>条件概率公理：</p><ul><li>对于任一事件 <script type="math/tex">A</script> ，有 <script type="math/tex">P(A \mid B) \geqslant 0</script></li><li><script type="math/tex; mode=display">P(\Omega \mid B) = 1</script></li></ul><p>所有概率运算均适用于条件概率运算：</p><script type="math/tex; mode=display">P ( \bigcup _ { i = 1 } ^ \infty A _ i \mid B ) = \sum _ { i = 1 } ^ \infty P ( A _ i \mid B )</script><script type="math/tex; mode=display">P(A_1 \cup A_2 \mid B) = P(A_1 \mid B) + P(A_2 \mid B) - P(A_1A_2 \mid B)</script><script type="math/tex; mode=display">P(\overline A \mid B) = 1 - P(A \mid B)</script><h3 id="3-2-乘法定理"><a href="#3-2-乘法定理" class="headerlink" title="3.2 乘法定理"></a>3.2 乘法定理</h3><p>将条件概率公式两边同时乘以 <script type="math/tex">P(A),P(A) > 0</script> ，可得乘法定理公式：</p><script type="math/tex; mode=display">P(AB) = P(A)P(B \mid A) = P(B)P(A \mid B)</script><p>将乘法定理推广到三个事件的情形，设<script type="math/tex">A,B,C</script> 为三个事件，且 <script type="math/tex">P(AB) > 0</script> ：</p><script type="math/tex; mode=display">P(ABC) = P(C \mid AB)P(AB) = P(C \mid AB)P(B \mid A)P(A)</script><p>一般地，设 <script type="math/tex">n</script> 个事件为 <script type="math/tex">A_1,A_2,...,A_n</script> ，若 <script type="math/tex">P(A_1A_2...A _ { n -1 } ) > 0</script> ，则有：</p><script type="math/tex; mode=display">P(A_1A_2...A_n) = P(A_1)P(A_2 \mid A_1)P(A_3 \mid A_1A_2)...P(A_n \mid A_1A_2...A_{n-1})</script><h3 id="3-3-划分与全概率公式"><a href="#3-3-划分与全概率公式" class="headerlink" title="3.3 划分与全概率公式"></a>3.3 划分与全概率公式</h3><h4 id="3-3-1-样本空间的划分"><a href="#3-3-1-样本空间的划分" class="headerlink" title="3.3.1 样本空间的划分"></a>3.3.1 样本空间的划分</h4><p>设 <script type="math/tex">\Omega</script> 为样本空间，<script type="math/tex">A_1,A_2,...,A_n</script> 为 <script type="math/tex">\Omega</script> 的一个划分，其需满足条件：</p><ul><li><script type="math/tex; mode=display">A_iA_j = \varnothing \; , \; i \ne j \; ; \; i,j = 1,2,...,n</script></li><li><script type="math/tex; mode=display">\bigcup _ { i = 1 } ^ n A _ i = \Omega</script></li></ul><p>可以把对样本空间的划分理解为对样本空间中的所有基本事件进行没有遗漏、没有重复的分类分组</p><h4 id="3-3-2-全概率公式"><a href="#3-3-2-全概率公式" class="headerlink" title="3.3.2 全概率公式"></a>3.3.2 全概率公式</h4><p>设 <script type="math/tex">B</script> 为样本空间 <script type="math/tex">\Omega</script> 中的任一事件，<script type="math/tex">A_1,A_2,...,A_n</script> 为 <script type="math/tex">\Omega</script> 的一个划分，且 <script type="math/tex">P(A_i)>0,i=1,2,...,n</script> ，则有：</p><script type="math/tex; mode=display">P(B) = \sum _ { i = 1 } ^ n P(A_i)P(B \mid A_i)</script><h3 id="3-4-贝叶斯公式-逆概率公式"><a href="#3-4-贝叶斯公式-逆概率公式" class="headerlink" title="3.4 贝叶斯公式 / 逆概率公式"></a>3.4 贝叶斯公式 / 逆概率公式</h3><p>设样本空间为 <script type="math/tex">\Omega</script> ，<script type="math/tex">B</script> 为 <script type="math/tex">\Omega</script> 中的事件，<script type="math/tex">A_1,A_2,...,A_n</script> 为 <script type="math/tex">\Omega</script> 的一个划分，且 <script type="math/tex">P(B) > 0 , P(A_i) > 0 , i=1,2,...,n</script> ，则有：</p><script type="math/tex; mode=display">P(A_i \mid B) = \frac { P(A _ i)P(B \mid A _ i) } { \sum _ { j = 1 } ^ n P( A _ j )P(B \mid A_j) } \; , \; i = 1,2,...,n</script><h2 id="4-独立性"><a href="#4-独立性" class="headerlink" title="4 独立性"></a>4 独立性</h2><p>若事件 <script type="math/tex">A _ 1 , A _ 2</script> 满足：<script type="math/tex">P(A_1A_2) = P(A_1)P(A_2)</script> ，则称 <script type="math/tex">A _ 1 , A _ 2</script> 是相互独立的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="韩旭里, 谢永钦.概率论与数理统计[M].北京大学出版社:北京,2018:02-25.">[1]</span></a></sup></p><p>若事件 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 相互独立，则 <script type="math/tex">A</script> 与 <script type="math/tex">\overline B</script> ，<script type="math/tex">\overline A</script> 与 <script type="math/tex">B</script> ，<script type="math/tex">\overline A</script> 与 <script type="math/tex">\overline B</script> 也相互独立</p><p>若事件 <script type="math/tex">A,B</script> 相互独立，且 <script type="math/tex">0 < P(A) < 1</script> ，则 <script type="math/tex">P(B \mid A) = P(B \mid \overline A) = P(B)</script></p><p>若事件 <script type="math/tex">A _ 1 , A _ 2 , A _ 3</script> 满足以下条件，则称 <script type="math/tex">A _ 1 , A _ 2 , A _ 3</script> 为相互独立的事件：</p><ul><li><script type="math/tex; mode=display">P(A_1A_2) = P(A_1)P(A_2)</script></li><li><script type="math/tex; mode=display">P(A_1A_3) = P(A_1)P(A_3)</script></li><li><script type="math/tex; mode=display">P(A_2A_3) = P(A_2)P(A_3)</script></li><li><script type="math/tex; mode=display">P(A_1A_2A_3) = P(A_1)P(A_2)P(A_3)</script></li></ul><p>对 <script type="math/tex">n</script> 个事件 <script type="math/tex">A_1,A_2,...,A_n</script> ，若以下 <script type="math/tex">2^n - n - 1</script> 个条件成立，则称 <script type="math/tex">A_1,A_2,...,A_n</script> 是相互独立的事件：</p><ul><li><script type="math/tex; mode=display">P(A_iA_j) = P(A_i)P(A_j) , 1 \leqslant i < j \leqslant n</script></li><li><script type="math/tex; mode=display">P(A_iA_jA_k) = P(A_i)P(A_j)P(A_k) , 1 \leqslant i < j < k \leqslant n</script></li><li>……</li><li><script type="math/tex; mode=display">P(A_1A_2...A_n) = P(A_1)P(A_2)...P(A_n)</script></li></ul><p><strong>独立性的推论：</strong></p><ul><li>若 <script type="math/tex">n</script> 个事件 <script type="math/tex">A_1,A_2,...,A_n(n \geqslant 2)</script> 相互独立，则其中任意 <script type="math/tex">k(2 \leqslant k \leqslant n)</script> 个事件也相互独立</li><li>若 <script type="math/tex">n</script> 个事件 <script type="math/tex">A_1,A_2,...,A_n(n \geqslant 2)</script> 相互独立，则将其中任意多个事件换成其对立事件，所得的 <script type="math/tex">n</script> 个事件依然相互独立</li></ul><h2 id="5-排列组合"><a href="#5-排列组合" class="headerlink" title="5 排列组合"></a>5 排列组合</h2><h3 id="5-1-排列"><a href="#5-1-排列" class="headerlink" title="5.1 排列"></a>5.1 排列</h3><p>从 n 个人中 <strong>有顺序地</strong> 抽出 m 个人的抽取方法总数</p><script type="math/tex; mode=display">P _ n ^ m = \frac { n! } { (n-m)! } = n(n-1)(n-2)...(n-m+1)</script><p>从大的数字开始，往小的数字乘，乘“小的数字那么多”个<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="浣熊数学.如何通俗的解释排列公式和组合公式的含义？[EB/OL].https://www.zhihu.com/question/26094736/answer/610713978, 2019-06-12.">[2]</span></a></sup></p><h3 id="5-2-组合"><a href="#5-2-组合" class="headerlink" title="5.2 组合"></a>5.2 组合</h3><p>从 n 个人中 <strong>不计顺序地</strong> 抽出 m 个人的抽取方法总数</p><script type="math/tex; mode=display">C _ n ^ m = \frac { n! } { (n-m)!m! } = \frac { n(n-1)(n-2)...(n-m+1) } { m(m-1)(m-2) \times ... \times 1 }</script><p>从大的数字开始，往小的数字乘，乘“小的数字那么多”个，再除以“小的数字开始往小乘，乘小的数字那么多个”<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="浣熊数学.如何通俗的解释排列公式和组合公式的含义？[EB/OL].https://www.zhihu.com/question/26094736/answer/610713978, 2019-06-12.">[2]</span></a></sup></p><h3 id="5-3-组合数的基础运算"><a href="#5-3-组合数的基础运算" class="headerlink" title="5.3 组合数的基础运算"></a>5.3 组合数的基础运算</h3><ol><li><script type="math/tex">C _ n ^ m = C _ n ^ { n - m }</script> ：当 <script type="math/tex">m</script> 值较大时，将其化小运算</li><li><script type="math/tex">C _ n ^ { m - 1 } + C _ n ^ m = C _ { n + 1 } ^ m</script> ：处理两个组合数相加</li><li><script type="math/tex">C _ n ^ 0 + C _ n ^ 1 + ... + C _ n ^ n = 2 ^ n</script> ：处理一系列“底下相同的”组合数相加的问题<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="浣熊数学.如何通俗的解释排列公式和组合公式的含义？[EB/OL].https://www.zhihu.com/question/26094736/answer/610713978, 2019-06-12.">[2]</span></a></sup></li><li><script type="math/tex">C _ r ^ r + C _ { r + 1 } ^ r + ... + C _ n ^ r = 2 ^ n</script> ：处理一系列“上面相同的”组合数相加的问题<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="浣熊数学.如何通俗的解释排列公式和组合公式的含义？[EB/OL].https://www.zhihu.com/question/26094736/answer/610713978, 2019-06-12.">[2]</span></a></sup></li></ol><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6 参考资料"></a>6 参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>韩旭里, 谢永钦.概率论与数理统计[M].北京大学出版社:北京,2018:02-25.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>浣熊数学.如何通俗的解释排列公式和组合公式的含义？[EB/OL].<a href="https://www.zhihu.com/question/26094736/answer/610713978">https://www.zhihu.com/question/26094736/answer/610713978</a>, 2019-06-12.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>HCI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人机交互</tag>
      
      <tag>数据分析,概率统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计学基础概念</title>
    <link href="/2021/05/03/4-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/05/03/4-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-总体与样本"><a href="#1-总体与样本" class="headerlink" title="1 总体与样本"></a>1 总体与样本</h2><h3 id="1-1-总体"><a href="#1-1-总体" class="headerlink" title="1.1 总体"></a>1.1 总体</h3><p><strong>总体定义：</strong> 统计学所关注和研究的个体的全部</p><p><strong>总体类型：</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="总体（统计学概念） - 百度百科">[1]</span></a></sup></p><ul><li>有限总体：总体所包含的单位数是有限的，可以进行全面调查，也可以进行非全面调查，如人口数、企业数、商店数等</li><li>无限总体：总体所包含的单位数是无限的，只能抽取一部分单位进行非全面调查，据以推断总体，如时间序列、连续生产的某种产品的生产数、海鱼资源数等</li></ul><h3 id="1-2-样本"><a href="#1-2-样本" class="headerlink" title="1.2 样本"></a>1.2 样本</h3><p><strong>样本定义：</strong> 总体中抽取的所要考查的元素总称<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="武汇岳.人机交互中的用户行为研究[M].中山大学出版社:广州市,2019:69-82.">[2]</span></a></sup></p><p><strong>样本容量：</strong> 样本中个体的数量</p><h3 id="1-3-抽样与统计"><a href="#1-3-抽样与统计" class="headerlink" title="1.3 抽样与统计"></a>1.3 抽样与统计</h3><p><strong>抽样定义：</strong> 从总体中抽取样本</p><p><strong>抽样方法：</strong><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="样本（统计学概念） -_百度百科">[3]</span></a></sup></p><ul><li>简单随机抽样：设一个总体个数为N，通过逐个抽取的方法抽取一个样本，且每次抽取时，每个个体被抽到的概率相等，适用于总体个数较少的情况</li><li>系统抽样：当总体的个数比较多的时候，首先把总体分成均衡的几部分，然后按照预先定的规则，从每一个部分中抽取一些个体，得到所需要的样本</li><li>分层抽样：将总体分成互不交叉的层，然后按照一定的比例，从各层中独立抽取一定数量的个体，得到所需样本，适用于总体由差异明显的几部分组成的情形</li><li>整群抽样 / 聚类抽样：将总体中各单位归并成若干个互不交叉、互不重复的集合，称之为群，然后以群为抽样单位抽取样本；要求各群有较好的代表性，即群内各单位的差异要大，群间差异要小。</li><li>多段抽样：把从调查总体中抽取样本的过程，分成两个或两个以上阶段进行</li></ul><p><strong>统计：</strong> 根据样本反推总体</p><p><strong>抽样误差：</strong> 在样本统计量和总体参数之间由于随机抽样过程中的偶然性因素所导致的误差<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="武汇岳.人机交互中的用户行为研究[M].中山大学出版社:广州市,2019:69-82.">[2]</span></a></sup></p><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h2><h3 id="2-1-变量与数据"><a href="#2-1-变量与数据" class="headerlink" title="2.1 变量与数据"></a>2.1 变量与数据</h3><p><strong>变量定义：</strong> 用于度量个体特征属性的指标，对于不同个体可以取不同数值，也可用于描述外部环境条件的变化</p><p><strong>数据 / 原始分数：</strong> 对个体进行测量之后得到的数据</p><p><strong>描述性统计：</strong> 对原始数据进行总结、组织和简化的统计过程，原始数据被转化为表格或图示</p><p><strong>推论性统计：</strong> 通过对样本的学习，得到对总体的归纳和概括</p><h3 id="2-2-变量的类型"><a href="#2-2-变量的类型" class="headerlink" title="2.2 变量的类型"></a>2.2 变量的类型</h3><p><strong>总体划分：</strong></p><ul><li><strong>自变量：</strong> 可被研究者控制的变量，通常由被试面临的两个及以上的处理条件构成</li><li><strong>因变量：</strong> 可观察的用于评估实验处理所产生的效应所产生的变量</li></ul><p><strong>细分类别：</strong><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="武汇岳.人机交互中的用户行为研究[M].中山大学出版社:广州市,2019:69-82.">[2]</span></a></sup></p><ul><li>类别变量：变量的不同观察值仅代表不同类别的事物，不代表数量差异</li><li>顺序变量：有方向和前后顺序的分类，能判断差异方向，但无法判断差异量大小</li><li>等距变量：有序，变量观察值之间可以比较大小，且差值有实际意义；零值不意味着“没有”，而是数学意义的数值 0</li><li>等比变量：有绝对的零点，0 代表没有</li></ul><h2 id="3-均值与中位数"><a href="#3-均值与中位数" class="headerlink" title="3 均值与中位数"></a>3 均值与中位数</h2><p>基础统计量，用于判断样本的基本情况，无法判断样本的离散程度</p><h3 id="3-1-算术平均数"><a href="#3-1-算术平均数" class="headerlink" title="3.1 算术平均数"></a>3.1 算术平均数</h3><p>均值表示一组数据集中趋势的量数<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="平均数 -_百度百科">[4]</span></a></sup>，其中最常见，在 HCI 领域最常应用的是算术平均数</p><script type="math/tex; mode=display">\overline{X} = \frac {1} {n} \sum ^ n _ {i=1} X_i</script><ul><li><p><script type="math/tex">X</script> ：样本的观察值</p></li><li><p><script type="math/tex">n</script> ：样本数量</p></li></ul><h3 id="3-2-中位数"><a href="#3-2-中位数" class="headerlink" title="3.2 中位数"></a>3.2 中位数</h3><p>中位数是按顺序排列的一组数据中居于中间位置的数<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="中位数_- 百度百科">[5]</span></a></sup></p><p>将样本数据从低到高排序，当样本数量 <script type="math/tex">n</script> 为奇数时：</p><script type="math/tex; mode=display">M_{0.5} = X _ \frac{n+1}{2}</script><p>将样本数据从低到高排序，当样本数量 <script type="math/tex">n</script> 为偶数时：</p><script type="math/tex; mode=display">M_{0.5} = \frac{1}{2} \left( X _ \frac{n}{2} + X _ { \frac{n}{2} + 1 } \right)</script><h2 id="4-变异性"><a href="#4-变异性" class="headerlink" title="4 变异性"></a>4 变异性</h2><p>变异性描述的是同一样本中不同个体之间聚集或分散开的程度或者趋势<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="变异性_- 百度百科">[6]</span></a></sup></p><p>变异性的衡量：先求均值，然后绘制散点图，查看样本观察值偏离均值的程度<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="武汇岳.人机交互中的用户行为研究[M].中山大学出版社:广州市,2019:69-82.">[2]</span></a></sup></p><h2 id="5-自由度"><a href="#5-自由度" class="headerlink" title="5 自由度"></a>5 自由度</h2><p>自由度决定了样本中独立的和可以自由变化的数值的个数，常用于抽样分布中<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="自由度（统计学术语）- 百度百科">[7]</span></a></sup></p><p>当样本量为 <script type="math/tex">n</script> 时，样本的自由度 <script type="math/tex">df = n - 1</script></p><h2 id="6-差异量数"><a href="#6-差异量数" class="headerlink" title="6 差异量数"></a>6 差异量数</h2><p>差异量数表示样本数据偏离中间数值的趋势的量数，反映样本频率分布的离散程度</p><p>差异量数大，表示各数值分布的范围广且参差不齐；差异量数小，表示各数值较集中、整齐，波动的范围幅度小</p><p><strong>差异量数对比：</strong> <sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="差异量数_- 百度百科 ">[8]</span></a></sup></p><div class="table-container"><table><thead><tr><th style="text-align:left">差异量种类</th><th style="text-align:left">利用数据信息情况</th><th style="text-align:left">反映差异效果</th><th style="text-align:left">主要特点</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">平均差</td><td style="text-align:left">利用全部信息</td><td style="text-align:left">无极端数据时更适用，数据服从正态分布或均匀分布更好</td><td style="text-align:left">①反应灵敏；②受极端数据影响大；③代数运算困难</td><td style="text-align:left">掌握全部数据信息才能使用</td></tr><tr><td style="text-align:left">方差</td><td style="text-align:left">利用全部信息</td><td style="text-align:left">无极端数据时更适用，数据服从正态分布或均匀分布更好</td><td style="text-align:left">①反应灵敏；②能做代数运算；③受抽样变动影响小；④具有可加性</td><td style="text-align:left">掌握全部数据信息才能使用</td></tr><tr><td style="text-align:left">百分差 / 四分差</td><td style="text-align:left">只利用位置信息</td><td style="text-align:left">有极端数据时更适用</td><td style="text-align:left">①受极端数据影响小；②不能进行代数运算</td><td style="text-align:left">只要掌握数据部分信息就可使用</td></tr><tr><td style="text-align:left">全距</td><td style="text-align:left">只利用最值信息</td><td style="text-align:left">低效</td><td style="text-align:left">①不灵敏不稳定；②受抽样变动影响</td><td style="text-align:left">只要掌握极值数据</td></tr></tbody></table></div><h3 id="6-1-平均差"><a href="#6-1-平均差" class="headerlink" title="6.1 平均差"></a>6.1 平均差</h3><p>计算算术平均数与各数据的平均距离，直观反映数据差异程度</p><p>但由于引入绝对值，难以进行代数运算，理论分析困难，所以运用较少</p><script type="math/tex; mode=display">MD = \frac{1}{N} \sum _ { i = 1 } ^ N \left | x _ i - \overline x \right |</script><p>平均差越大，各标志值与算术平均数的差异程度越大，该算术平均数的<strong>代表性</strong>越小<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="平均差_- 百度百科">[9]</span></a></sup></p><p>平均差越小，各标志值与算术平均数的差异程度越小，该算术平均数的<strong>代表性</strong>越大<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="平均差_- 百度百科">[9]</span></a></sup></p><h3 id="6-2-百分差与四分差"><a href="#6-2-百分差与四分差" class="headerlink" title="6.2 百分差与四分差"></a>6.2 百分差与四分差</h3><p>百分位差与四分位差只利用数据的部分信息，不能进行代数运算，反应不灵敏</p><p>但当极端数据不清楚或数据信息不完整时，只能使用百分差与四分差</p><p>百分位差：<script type="math/tex">P _ { p _ i } - P _ { p _ j }</script></p><p>四分位差：<script type="math/tex">QD = ( Q _ 3 - Q _ 1 ) \div 2</script></p><h3 id="6-3-极差-全距"><a href="#6-3-极差-全距" class="headerlink" title="6.3 极差 / 全距"></a>6.3 极差 / 全距</h3><p>数据最大值和最小值的差值，衡量离散程度的稳健性不足，精度低</p><h3 id="6-4-方差与标准差"><a href="#6-4-方差与标准差" class="headerlink" title="6.4 方差与标准差"></a>6.4 方差与标准差</h3><p><strong>总体方差：</strong></p><script type="math/tex; mode=display">\sigma ^ 2 = \frac {1} {N} \sum _ {i=1} ^ {N} ( X_i - \mu ) ^ 2</script><ul><li><script type="math/tex">\mu</script> ：总体均值</li><li><script type="math/tex">X_i</script> ：第 <script type="math/tex">i</script> 个个体的观察值</li><li><script type="math/tex">N</script> ：总体中包含的个体总数</li></ul><p><strong>样本方差：</strong></p><script type="math/tex; mode=display">{S ^ 2} = \frac { 1 } { n - 1 } \sum _ {i=1} ^ {N} ( X_i - \overline X ) ^ 2</script><ul><li><p>由于总体均值难以获取，实际计算样本方差时，分母校正为除以 <script type="math/tex">n - 1</script></p></li><li><p><script type="math/tex">\overline X</script> ：样本均值</p></li><li><script type="math/tex">n - 1</script> ：自由度</li></ul><p><strong>标准差：</strong> 样本方差开平方，使其量纲恢复到与原先变量统一的水平</p><h2 id="7-假设检验"><a href="#7-假设检验" class="headerlink" title="7 假设检验"></a>7 假设检验</h2><h3 id="7-1-假设检验定义"><a href="#7-1-假设检验定义" class="headerlink" title="7.1 假设检验定义"></a>7.1 假设检验定义</h3><p>假设检验定义：基于样本的数据来评估和推断关于总体的假设或猜想<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="武汇岳.人机交互中的用户行为研究[M].中山大学出版社:广州市,2019:69-82.">[2]</span></a></sup></p><h3 id="7-2-假设检验的逻辑和基本步骤"><a href="#7-2-假设检验的逻辑和基本步骤" class="headerlink" title="7.2 假设检验的逻辑和基本步骤"></a>7.2 假设检验的逻辑和基本步骤</h3><h4 id="7-2-1-建立统计假设"><a href="#7-2-1-建立统计假设" class="headerlink" title="7.2.1 建立统计假设"></a>7.2.1 建立统计假设</h4><p><strong>虚拟假设</strong> <script type="math/tex">H_0 ( \mu ＝ \mu _ 0 )</script> ：对总体均值做的零假设，表示样本均值与总体均值的差异由抽样误差引起，该差异没有统计学意义</p><p><strong>对立假设</strong> <script type="math/tex">H_1 ( \mu \neq \mu _ 0 )</script> ：样本均值与总体均值存在显著差异，与抽样误差无关</p><h4 id="7-2-2-设置决策的标准"><a href="#7-2-2-设置决策的标准" class="headerlink" title="7.2.2 设置决策的标准"></a>7.2.2 设置决策的标准</h4><p>假设 <script type="math/tex">H_0</script> 为真，样本均值的概率分布成正态分布曲线</p><p><strong>α 水平：</strong> 即显著性水平，定义了非常不可能的样本结果，位于曲线两侧，通常取 5%，表示当前决策犯错的概率小于 5%</p><p><strong>临界区：</strong> 即极其低概率值样本的区域，如果零假设 <script type="math/tex">H_0</script> 为真，样本值不太可能落在临界区内</p><p><strong>Z 值：</strong> 即临界区的边界，通过标准正态表确定具体数值</p><h4 id="7-2-3-收集数据并计算样本统计量"><a href="#7-2-3-收集数据并计算样本统计量" class="headerlink" title="7.2.3 收集数据并计算样本统计量"></a>7.2.3 收集数据并计算样本统计量</h4><p>计算样本的<strong>均值</strong>和<strong>标准差</strong>，进而查找标准正态表确定 <script type="math/tex">Z</script> 值和 <script type="math/tex">p</script> 值</p><p>Z 值描述了样本平均数相对于零假设 <script type="math/tex">H_0</script> 中假设的总体平均数的精确位置</p><h4 id="7-2-4-基于规则和统计量作出决策：能否拒绝零假设"><a href="#7-2-4-基于规则和统计量作出决策：能否拒绝零假设" class="headerlink" title="7.2.4 基于规则和统计量作出决策：能否拒绝零假设"></a>7.2.4 基于规则和统计量作出决策：能否拒绝零假设</h4><p>一般情况下取 α = 0.05</p><p><strong>p &lt; 0.05 ：</strong> 拒绝零假设，样本均值和总体均值具有显著性差异，差别有统计学意义</p><p><strong>p &gt; 0.05 ：</strong> 无法拒绝零假设，差别无统计学意义，注意该说法不等于「 接受零假设 」</p><p>「 无法拒绝零假设 」只能说明当前数据无法证明实验处理对样本有影响，当前的证据无法证明零假设错误</p><h3 id="7-3-假设检验中常见的错误类型"><a href="#7-3-假设检验中常见的错误类型" class="headerlink" title="7.3 假设检验中常见的错误类型"></a>7.3 假设检验中常见的错误类型</h3><h4 id="7-3-1-类型Ⅰ错误"><a href="#7-3-1-类型Ⅰ错误" class="headerlink" title="7.3.1 类型Ⅰ错误"></a>7.3.1 类型Ⅰ错误</h4><p>零假设本来是成立的，但实验结论却拒绝了这一假设</p><p>实验处理本来对样本没影响，结论却认为有影响</p><p><strong>解决方法：</strong> 尽量选用更小的 α 值，收集更多的研究证据</p><h4 id="7-3-2-类型Ⅱ错误"><a href="#7-3-2-类型Ⅱ错误" class="headerlink" title="7.3.2 类型Ⅱ错误"></a>7.3.2 类型Ⅱ错误</h4><p>零假设本来不成立，但实验结论却没有拒绝这一假设</p><p>实验处理本来对样本有影响，结论却认为没有影响</p><p>严重程度比类型Ⅰ错误轻得多</p><h3 id="7-4-假设检验的方向性"><a href="#7-4-假设检验的方向性" class="headerlink" title="7.4 假设检验的方向性"></a>7.4 假设检验的方向性</h3><p><strong>双边假设：</strong> 拒绝域落在概率分布图的双侧，零假设为样本的均值等于总体均值</p><p><strong>单边假设：</strong> 拒绝域落在概率分布图的左侧或右侧，零假设为样本均值大于等于或小于等于总体均值</p><h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8 参考资料"></a>8 参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://baike.baidu.com/item/总体/19951273?fr=aladdin">总体（统计学概念） - 百度百科</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>武汇岳.人机交互中的用户行为研究[M].中山大学出版社:广州市,2019:69-82.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://baike.baidu.com/item/样本/19974592#viewPageContent">样本（统计学概念） -_百度百科</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://baike.baidu.com/item/平均数/11031224?fromtitle=均值&amp;fromid=5922988&amp;fr=aladdin">平均数 -_百度百科</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://baike.baidu.com/item/中位数">中位数_- 百度百科</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://baike.baidu.com/item/变异性">变异性_- 百度百科</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://baike.baidu.com/item/自由度/5936984">自由度（统计学术语）- 百度百科</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://baike.baidu.com/item/差异量数/9367193?fromtitle=变异量数&amp;fromid=10840782">差异量数_- 百度百科 </a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://baike.baidu.com/item/平均差">平均差_- 百度百科</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人机交互</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCI 研究方法：一致性分数公式</title>
    <link href="/2021/04/30/3-%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%95%B0/"/>
    <url>/2021/04/30/3-%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-一致性分数计算公式"><a href="#1-一致性分数计算公式" class="headerlink" title="1 一致性分数计算公式"></a>1 一致性分数计算公式</h2><h3 id="1-1-一致性分数定义"><a href="#1-1-一致性分数定义" class="headerlink" title="1.1 一致性分数定义"></a>1.1 一致性分数定义</h3><p>对于<strong>给定任务</strong>，用户选择<strong>同一或相似手势</strong>的可能性，或者说，不同用户在参与式手势设计过程中的<strong>选择分歧程度</strong> <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="武汇岳.视觉手势用户界面：理论、方法和应用[M].中山大学出版社:广州市,2019:57-65.">[1]</span></a></sup></p><p>在参与式设计过程中采用启发式手势设计方法的目的是解决 手势分歧问题 与 词汇分歧问题</p><ul><li><strong>手势分歧问题：</strong> 广泛存在于自然手势交互领域，因用户做出了系统预定义之外的手势，系统无法识别该手势而产生</li><li><strong>词汇分歧问题：</strong> 用户所偏好的手势与设计师认为合理的手势之间的偏差与分歧</li></ul><h3 id="1-2-公式详解"><a href="#1-2-公式详解" class="headerlink" title="1.2 公式详解"></a>1.2 公式详解</h3><p>一致性分数（ Agreement Rate ）计算公式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="VATAVU R-D, WOBBROCK J O, 2015. Formalizing Agreement Analysis for Elicitation Studies: New Measures, Significance Test, and Toolkit[C/OL]//Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems. Seoul Republic of Korea: ACM: 1325–1334[2021–04–30]. https://dl.acm.org/doi/10.1145/2702123.2702223. DOI:10.1145/2702123.2702223.">[2]</span></a></sup>：</p><script type="math/tex; mode=display">AR(r) = \frac{| P |}{| P |-1} \sum _{P_i \in P} \left (\frac {| P_i |}{| P |} \right) ^2 - \frac {1}{| P |-1} \tag 1</script><p>各变量内涵：</p><p>（1）<script type="math/tex">r</script> ：待以手势完成的某一个目标任务（ 研究对象 referent ）</p><p>（2）<script type="math/tex">P</script> ：针对 <script type="math/tex">r</script> 提出的所有的手势候选集合（ 所有提案 proposals 的集合 ）</p><p>（3）<script type="math/tex">|P|</script> ：所有手势候选集合的大小</p><p>（4）<script type="math/tex">P_i</script> ：总集合 <script type="math/tex">P</script> 中某一个包含了一致手势的子集（ <script type="math/tex">P</script> 中相同或相似提案的子集 ）</p><p>（5）<script type="math/tex">|P_i|</script> ：$P_i$ 中手势的个数</p><h3 id="1-3-实例对比"><a href="#1-3-实例对比" class="headerlink" title="1.3 实例对比"></a>1.3 实例对比</h3><h4 id="1-3-1-实例-1-：15-5"><a href="#1-3-1-实例-1-：15-5" class="headerlink" title="1.3.1 实例 1 ：15 / 5"></a>1.3.1 实例 1 ：15 / 5</h4><p>假设实验邀请了 20 名被试，对于特定的任务目标 <script type="math/tex">r_a</script> ，共收集到 <script type="math/tex">|P|=20</script> 个候选手势方案</p><p>其中 15 个可被归类为第一类手势，剩余 5 个可被归类为第二类手势 → 可得：<script type="math/tex">|P_1|=15\;,\;|P_2|=5</script></p><p>代入公式运算可得任务 <script type="math/tex">r_a</script> 一致性分数 <script type="math/tex">AR(r_a)</script> 为 <strong>.605</strong></p><script type="math/tex; mode=display">AR(r_a) = \frac{| P |}{| P |-1} \sum _{ P_i \in P} \left( \frac {| P_i |}{| P |} \right) ^2 - \frac {1}{| P |-1} = \frac{20}{19} \times \frac{15^2+5^2}{20^2} - \frac{1}{19} = .605</script><h4 id="1-3-2-实例-2-：15-3-2"><a href="#1-3-2-实例-2-：15-3-2" class="headerlink" title="1.3.2 实例 2 ：15 / 3 / 2"></a>1.3.2 实例 2 ：15 / 3 / 2</h4><p>假设实验邀请了 $20$ 名被试，对于特定的任务目标 <script type="math/tex">r_b</script> ，共收集到 <script type="math/tex">|P|=20</script> 个候选手势方案</p><p>其中 15 个可被归类为第一类手势，另外 3 个可被归类为第二类手势，余下 2 个可被归类为第三类手势 → 可得：<script type="math/tex">|P_1|=15， |P_2|=3， |P_3|=2</script></p><p>代入公式运算可得任务 $r_a$ 一致性分数 <script type="math/tex">AR(r_a)</script> 为 <strong>.574</strong> → 一致性分数比上方例子降低，事实也的确如此</p><script type="math/tex; mode=display">AR(r_b) = \frac{| P |}{| P |-1} \sum _{ P_i \in P}(\frac {| P_i |}{| P |})^2 - \frac {1}{| P |-1} = \frac{20}{19} \times \frac{15^2+3^2+2^2}{20^2} - \frac{1}{19} = .574</script><h3 id="1-4-一致性分析工具包"><a href="#1-4-一致性分析工具包" class="headerlink" title="1.4 一致性分析工具包"></a>1.4 一致性分析工具包</h3><p>Vatatu 提供了 AGATE（ <u>AG</u>reement <u>A</u>nalysis <u>T</u>oolkit ）<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="VATAVU R-D, WOBBROCK J O, 2015. Formalizing Agreement Analysis for Elicitation Studies: New Measures, Significance Test, and Toolkit[C/OL]//Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems. Seoul Republic of Korea: ACM: 1325–1334[2021–04–30]. https://dl.acm.org/doi/10.1145/2702123.2702223. DOI:10.1145/2702123.2702223.">[2]</span></a></sup>，一个简洁高效的一致性分析工具包</p><p>AGATE 接收以<strong>矩阵格式</strong>输入的数据：</p><ul><li>每个研究对象（ referent ）的数据占据一列</li><li>每个参与者（被试）的数据占据一行</li></ul><p>AGATE 功能：</p><ul><li>计算选定研究对象的一致性分数、不一致分数和协一致性分数</li><li>在 <script type="math/tex">p = .05\;,\;.01\;,\;.001</script> 三种显著性水平上，分别报告选定研究对象对一致性分数的影响显著程度</li></ul><p>工具包下载链接：<a href="http://depts.washington.edu/acelab/proj/dollar/agate.html">AGATe Tool</a></p><p><img src="/img/article/003/AGATe.jpg" alt="AGATe 工具包界面展示"></p><h2 id="3-不一致性分数"><a href="#3-不一致性分数" class="headerlink" title="3 不一致性分数"></a>3 不一致性分数</h2><p>不一致性分数（ Disagreement Rate ）与研究对象 $r$ 的一致性分数互补，二者之和始终为 1</p><p>不一致性分数计算公式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="VATAVU R-D, WOBBROCK J O, 2015. Formalizing Agreement Analysis for Elicitation Studies: New Measures, Significance Test, and Toolkit[C/OL]//Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems. Seoul Republic of Korea: ACM: 1325–1334[2021–04–30]. https://dl.acm.org/doi/10.1145/2702123.2702223. DOI:10.1145/2702123.2702223.">[2]</span></a></sup>：</p><script type="math/tex; mode=display">DR(r) = - \frac{| P |}{| P | - 1 } \sum _{P_i \in P} \left( \frac {| P_i |}{| P |} \right )^2 + \frac {|P|}{| P |-1} \tag 2</script><h2 id="4-协一致性分数"><a href="#4-协一致性分数" class="headerlink" title="4 协一致性分数"></a>4 协一致性分数</h2><h3 id="4-1-两个研究对象之间"><a href="#4-1-两个研究对象之间" class="headerlink" title="4.1 两个研究对象之间"></a>4.1 两个研究对象之间</h3><p>2 个研究对象 <script type="math/tex">r_1</script> 和 <script type="math/tex">r_2</script> 的协一致性分数（ Coagreement Rate ）定义：2 个研究对象之间的一致性有多少是相关 / 重合的</p><p>计算方法：对 <script type="math/tex">r_1</script> 和 <script type="math/tex">r_2</script> 都提出了一致的提案的参与者的对数除以潜在保持一致的参与者的总对数</p><p>研究对象数量 <script type="math/tex">k = 2</script> 时，协一致性分数的计算公式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="VATAVU R-D, WOBBROCK J O, 2015. Formalizing Agreement Analysis for Elicitation Studies: New Measures, Significance Test, and Toolkit[C/OL]//Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems. Seoul Republic of Korea: ACM: 1325–1334[2021–04–30]. https://dl.acm.org/doi/10.1145/2702123.2702223. DOI:10.1145/2702123.2702223.">[2]</span></a></sup>：</p><script type="math/tex; mode=display">CR(r_1,r_2) = \frac{ \sum _ {i=1} ^ {n} \delta _ { i , 1 } · \delta _ { i , 2 } } {n} \; , \; n = \frac{1}{2}|P|(|P|-1) \tag3</script><h3 id="4-2-两个以上的研究对象之间"><a href="#4-2-两个以上的研究对象之间" class="headerlink" title="4.2 两个以上的研究对象之间"></a>4.2 两个以上的研究对象之间</h3><p>k - 协一致性分数 ：用于描述成对的被试在多大程度上会对 <script type="math/tex">k</script> 个研究对象 <script type="math/tex">{r_1, r_2, …,r_k}\;,\; 2 \leq k \leq |P|</script> 同时提出一致的提案</p><p>研究对象 <script type="math/tex">k \geq 2</script> 时，协一致性分数的计算公式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="VATAVU R-D, WOBBROCK J O, 2015. Formalizing Agreement Analysis for Elicitation Studies: New Measures, Significance Test, and Toolkit[C/OL]//Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems. Seoul Republic of Korea: ACM: 1325–1334[2021–04–30]. https://dl.acm.org/doi/10.1145/2702123.2702223. DOI:10.1145/2702123.2702223.">[2]</span></a></sup>：</p><script type="math/tex; mode=display">CR(r_1,r_2, …,r_k) = \frac {1} {n} \sum _ {i=1} ^ {n} \prod _ {j=1} ^ k \delta _ { i , j } \; , \; n = \frac{1}{2}|P|(|P|-1) \tag4</script><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>武汇岳.视觉手势用户界面：理论、方法和应用[M].中山大学出版社:广州市,2019:57-65.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>VATAVU R-D, WOBBROCK J O, 2015. Formalizing Agreement Analysis for Elicitation Studies: New Measures, Significance Test, and Toolkit[C/OL]//Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems. Seoul Republic of Korea: ACM: 1325–1334[2021–04–30]. <a href="https://dl.acm.org/doi/10.1145/2702123.2702223">https://dl.acm.org/doi/10.1145/2702123.2702223</a>. DOI:<a href="https://doi.org/10.1145/2702123.2702223">10.1145/2702123.2702223</a>.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>HCI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>交互设计</tag>
      
      <tag>人机交互</tag>
      
      <tag>论文笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCI 概念解析：元组</title>
    <link href="/2021/04/28/2-%E5%85%83%E7%BB%84%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/04/28/2-%E5%85%83%E7%BB%84%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-元组概念"><a href="#1-元组概念" class="headerlink" title="1 元组概念"></a>1 元组概念</h2><p>元组（ Tuple ）是关系数据库中的基本概念</p><p>在关系模型中：</p><ul><li>关系：对应一张二维表</li><li>元组：表格中的一行，即数据库中的每条记录，包含所有属性的信息<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="元组 | 百度百科词条">[1]</span></a></sup></li><li>属性：表格中的一列，相当于记录中的一个字段</li><li>关键字：可唯一标识元组的属性或属性集</li></ul><p>在 <code>Python</code> 中，元组与列表概念类似，区别在于元组的元素<strong>不能修改</strong></p><h2 id="2-元组实操"><a href="#2-元组实操" class="headerlink" title="2 元组实操"></a>2 元组实操</h2><h3 id="2-1-创建元组"><a href="#2-1-创建元组" class="headerlink" title="2.1 创建元组"></a>2.1 创建元组</h3><p>在小括号 <code>( )</code> 中添加元素，并使用逗号隔开即可创建</p><p>元组下标索引起始值为 0</p><blockquote><p>对比：列表使用的是方括号 <code>[ ]</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">tup0 = ()   <span class="hljs-comment"># 空元组创建</span><br>tup1 = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>)<br>tup2 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> )<br>tup3 = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>   <span class="hljs-comment"># 不用括号也可以</span><br><br><span class="hljs-comment"># 元组中只包含一个元素时，需要在元素后面添加逗号</span><br>tup4 = (<span class="hljs-number">50</span>,)   <span class="hljs-comment"># &lt;class &#x27;tuple&#x27;&gt;</span><br>tup5 = (<span class="hljs-number">50</span>)    <span class="hljs-comment"># &lt;class &#x27;int&#x27;&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="2-2-访问元组"><a href="#2-2-访问元组" class="headerlink" title="2.2 访问元组"></a>2.2 访问元组</h3><p>通过下标索引访问元组中的值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">tup1 = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>)<br>tup2 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> )<br> <br><span class="hljs-built_in">print</span> (tup1[<span class="hljs-number">0</span>])     <span class="hljs-comment"># Google</span><br><span class="hljs-built_in">print</span> (tup2[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>])   <span class="hljs-comment"># (2, 3, 4, 5)</span><br></code></pre></div></td></tr></table></figure><blockquote><p>索引截取口诀：左右空，取到头；左要取，右不取</p><ul><li>冒号左边空，则从偏移量为0的元素开始取</li><li>冒号右边空，则取到列表的最后一个元素</li><li>冒号左边数字对应的元素算入，右边的则不计入</li></ul></blockquote><h3 id="2-3-组合元组"><a href="#2-3-组合元组" class="headerlink" title="2.3 组合元组"></a>2.3 组合元组</h3><p>元组中的元素值不能被修改，但可以进行用 <code>+</code> 连接组合</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">tup1 = (<span class="hljs-number">12</span>, <span class="hljs-number">34.56</span>)<br>tup2 = (<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>)<br> <br><span class="hljs-comment"># tup1[0] = 100   修改元组元素将报错</span><br> <br><span class="hljs-comment"># 元组的连接组合：</span><br>tup3 = tup1 + tup2<br><span class="hljs-built_in">print</span> (tup3)   <span class="hljs-comment"># (12, 34.56, &#x27;abc&#x27;, &#x27;xyz&#x27;)</span><br></code></pre></div></td></tr></table></figure><h3 id="2-4-删除元组"><a href="#2-4-删除元组" class="headerlink" title="2.4 删除元组"></a>2.4 删除元组</h3><p>元组中的元素值不能被修改，但可以用 <code>del</code> 语句整体删除</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">tup = (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Runoob&#x27;</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">2000</span>)<br> <br><span class="hljs-built_in">print</span> (tup)<br><span class="hljs-keyword">del</span> tup<br><span class="hljs-comment"># 如再次使用 tup 变量将报错</span><br></code></pre></div></td></tr></table></figure><h2 id="3-元组运算"><a href="#3-元组运算" class="headerlink" title="3 元组运算"></a>3 元组运算</h2><div class="table-container"><table><thead><tr><th>Python 表达式</th><th>运行结果</th><th>作用</th></tr></thead><tbody><tr><td><code>(1,2,3)+(4,5,6)</code></td><td>(1,2,3,4,5,6)</td><td>连接</td></tr><tr><td><code>(&#39;Hi!&#39;,)*4</code></td><td>(‘Hi!’,’Hi!’,’Hi!’,’Hi!’)</td><td>复制</td></tr><tr><td><code>3 in (1,2,3)</code></td><td>True</td><td>判断元素是否存在</td></tr><tr><td><code>for x  in (1,2,3):print(x,)</code></td><td>1 2 3</td><td>迭代</td></tr></tbody></table></div><h2 id="4-元组相关函数"><a href="#4-元组相关函数" class="headerlink" title="4 元组相关函数"></a>4 元组相关函数</h2><p><code>len((1,2,3))</code>  ：计算元素个数</p><p><code>max(tuple)</code> ：返回元组中元素的最大值</p><p><code>min(tuple)</code> ：返回元组中元素的最小值</p><p><code>tuple(iterable)</code> ：将可迭代对象转换为元组<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="元组 | 菜鸟教程">[2]</span></a></sup></p><blockquote><p>可迭代对象：包括列表、元组、字典、字符串，可在 for 循环中使用的元素</p><p>可迭代对象的判断：使用 <code>isinstance()</code> 语句<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="可迭代对象详解 | 博客园">[3]</span></a></sup></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://baike.baidu.com/item/元组/3190018?fr=aladdin">元组 | 百度百科词条</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.runoob.com/python3/python3-tuple.html">元组 | 菜鸟教程</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/new-rain/p/9991932.html">可迭代对象详解 | 博客园</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>HCI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>交互设计</tag>
      
      <tag>人机交互</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我小介绍 &amp; 考研小分享</title>
    <link href="/2021/04/16/1-%E8%87%AA%E6%88%91%E5%B0%8F%E4%BB%8B%E7%BB%8D%20&amp;%20%E8%80%83%E7%A0%94%E5%B0%8F%E5%88%86%E4%BA%AB/"/>
    <url>/2021/04/16/1-%E8%87%AA%E6%88%91%E5%B0%8F%E4%BB%8B%E7%BB%8D%20&amp;%20%E8%80%83%E7%A0%94%E5%B0%8F%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>灯灯灯灯！我是 Jamie ，一个会因为生活缺乏挑战感而难受的人，一个虽然菜但胆子挺大的人。</p><p>去年毅然裸辞跨考，幸亏是一战成硕，弃文从理，入学后的研究领域大概率是人机交互 [ HCI ] ，相关领域的大佬前辈们带带我呀！</p><h2 id="关于建站动机"><a href="#关于建站动机" class="headerlink" title="关于建站动机"></a>关于建站动机</h2><p>其实从去年考研备考的时候，就已经萌生了自己建个网站的想法，毕竟都 0202 年了，怎么能不拥有一个属于自己的炫酷好看的网站呢！今年复试结束之后，终于有时间、有心情“整活”。在肝了 B 站上 10 多个建站攻略之后，我最后跟着 CodeSheep 大哥的 <a href="https://www.bilibili.com/video/BV1Yb411a7ty?share_source=copy_web">无坑版视频教程</a> 以及搭配热心网友的弹幕食用，在零基础的情况下把 <a href="https://hexo.io/zh-cn/">Hexo 框架</a> 顺利搭建起来。</p><p>因为初始主题着实有些不忍直视，我又在 B 站大神们的带飞下，入坑了 <a href="https://hexo.fluid-dev.com/docs/">Fluid 主题</a> ，目前部分页面外观仍在施工，不过至少比原来好看得多。接着我又倒腾了一波评论插件 <a href="https://twikoo.js.org/">Twikoo</a> ，把自己想象中博客里应该有的功能全部装上了。</p><p>接下来会自学一波 Java ，至少入个门，然后进一步探索博客的自定义内容。虽然是静态网站，但这对于个人使用，写写文章、做做笔记已经绰绰有余了。</p><h2 id="博客内容规划"><a href="#博客内容规划" class="headerlink" title="博客内容规划"></a>博客内容规划</h2><ul><li>考研经验分享 [ 交互设计类专业 / 工作党考研 ]</li><li>HCI 相关理论积累（概率统计、机器学习……）</li><li>HCI 优质论文笔记 &amp; 重点部分翻译</li><li>编程语言学习笔记 [ Python / Java ]</li><li>关于生活的碎碎念</li><li>其他的心血来潮</li></ul><h2 id="考研经验杂谈"><a href="#考研经验杂谈" class="headerlink" title="考研经验杂谈"></a>考研经验杂谈</h2><p>网络上关于考研备考过程的经验视频 / 推文 / 帖子数不胜数，关于硕士生涯规划的干货向分享也是不计其数，其中呼吁师弟师妹”加入内卷大军“的论调也似乎略占上风。在这里，我更希望分享一些前置性的心得，毕竟考研这个决定的重要性跟高考没差，是需要投入 2-3 年青春的重大风险投资。</p><p>如果现在正在阅读这篇博客的你也正考虑读研，我十分希望你能够保持理性和独立思考，审慎考虑后再做决定，切忌盲目跟风。</p><h3 id="1-明确考研理由"><a href="#1-明确考研理由" class="headerlink" title="1 明确考研理由"></a>1 明确考研理由</h3><h4 id="1-1-工作党"><a href="#1-1-工作党" class="headerlink" title="1.1 工作党"></a>1.1 工作党</h4><p>说说我发呆的时候想的一些“歪门邪道”，先扔一个函数：</p><script type="math/tex; mode=display">f(COP) = IOV^* - SOV - COC > 0 \tag1</script><script type="math/tex; mode=display">IOV^*=f(\delta_{salary},Career\:Length,Related\:Gains,...)\tag2</script><script type="math/tex; mode=display">COC = f(Corperation\:Condition,Working\:Condition,Physical\:Condition,Career\:Length...)\tag3</script><p>如公式 1 所示，理想状态下，（专硕）读研的 2 年为自己未来创造的 <strong>价值增值 ( Increment of Value ，IOV* )</strong> 至少应大于这 2 年按原职业生涯所能创造的 <strong>价值之和 ( Sum of Value ，SOV )</strong> ，而且 IOV<em> 至少应在未来可预见的 <em>*工作成本 ( Cost of Career ，COC )</em></em> 出现之前回收。</p><ul><li><p>价值增值量：我理解主要是两个方面，一是对当前专业对应的行业的钻研深度和实践能力所带来的主要收入的提升，另一个是副业，也就是当前专业相关的领域的能力掌握所创造的补充价值，如果决定读研，则尽可能多地扩大读研后的价值增值量。</p></li><li><p>工作成本：最显而易见的是健康情况下滑导致的医疗成本，还包括业务变动导致的搬迁成本等等，应综合考虑可见成本和隐藏的潜在成本。</p></li><li>职业生涯长度：即使 读研后的价值增值 = 原计划的价值之和 ，读研的价值依然没有得到体现，反而白白牺牲了 2-3 年（含备考）年轻时期效率较高的工作时间。因此在 COP &gt; 0 的同时，还应进一步按照行业发展前景、企业发展情况、自己的身体状态等因子综合估算自己的 <strong>黄金</strong> 职业生涯长度 和 职业生涯总长度 ，并将其纳入工作成本变量的考量中。</li></ul><p>这是一个很粗糙的“模型”，我表述得蛮意识流，其中的变量也很难精细地量化，不过还是希望能为你的考研决策带来些许更系统的思考。</p><p>对于初入职场的工作党来说，如果你有下面的想法，那么考研是较好的选择：</p><ul><li><strong>转行</strong> 进入薪酬水平更高的领域 → 一般意味着跨专业考研，难度较高，个人不推荐跨专业同时跨校</li><li><strong>晋升</strong> → 选择非全日制硕士，MBA 尤其吃香，前提是自己对职业前景持有积极态度</li></ul><p>反之，以后容易后悔的读研理由则包括：</p><ul><li>身边同事 / 同龄人好多去读了，我也想跟风一战</li><li>同专业升学，能去个给更多钱的公司 → 思考维度不足，例如离开当前企业只是因为企业文化，那很有可能读研后的企业文化依然无法令人满意</li></ul><h4 id="1-2-学生党"><a href="#1-2-学生党" class="headerlink" title="1.2 学生党"></a>1.2 学生党</h4><p>剩余的课业压力 + 大三学年的实习压力 + 大四学年的论文压力，对于学生党来说，时间和精力的分散导致考研备考任务相对繁重。因此，个人建议提早开始备考的时间，或者从大一开始就做足职业生涯规划，下定决心直接努力学好课业，冲保研。</p><p>不过话说回来，具有相对劣势的同时，相对优势也十分显著。学生党在考研时可以承担更大的风险，因此跨考冲击985、211、双一流高校，或是国内排名更前的高校，乃至“双跨“冲击就业前景更好的专业，都可以成为靠前的选择。</p><p>对了，顺便分享一点关于所谓的“薪酬”的思考——</p><p>很多企业在招聘宣传的时候都在说年薪，但年薪并不是计算自己薪酬最合理的方式，更好的计算方法是“时薪”，即 月薪 ÷ 本月总工作小时数 得到的数值，时薪将能反映出当前企业的“性价比”，举个栗子，996 - 10k 和 995 - 9k 你选哪个，反正我选后者（除非对自己身体素质自信），杠就你对2333。</p><h3 id="2-做足身心准备"><a href="#2-做足身心准备" class="headerlink" title="2 做足身心准备"></a>2 做足身心准备</h3><p>考研备考的难度因专业而异，但“一分耕耘一分收获”的道理在考研中是有效的，在作出考研的选择之后，应做足重返高三状态的身体和心理准备。</p><p>身体准备：</p><ul><li>坚持锻炼，在每天或隔天的学习日程中预留一定的锻炼时长，建议以有氧运动为主，避免运动过度</li><li>规律三餐，养好肠胃</li><li>不熬夜不熬夜不熬夜，重要的事情讲三遍，保持稳定的作息时间，将睡眠时长保持在 7 小时以上，为第二天学习养精蓄锐</li></ul><p>心理准备：</p><ul><li>坚持长期主义的思维，不与身边同学同事对比，把每个选择的效果放远到十年后来看</li><li>利用上瘾模型（以后开篇博文细说），给自己多变的奖励，而不是完全靠着所谓的“自律”约束自己，因为大部分人都做不到完全自律</li><li>做题正确率不高的时候，保持正确的心态——现在出错好过最后考试的时候出错，现在每错一道，考试的时候就少错一道</li><li>考前焦虑很大概率会发生，闭上眼睛深呼吸、大喊大叫都是较好的缓解方法</li></ul><h3 id="3-个人备考策略"><a href="#3-个人备考策略" class="headerlink" title="3 个人备考策略"></a>3 个人备考策略</h3><p>这部分并不是我想说的重点，因此简单聊聊少许要点，而不会系统地谈。</p><p>网上各种方法铺天盖地，但请你记住：适合自己的才是最好的，自己探索出来的方法最好，不必完全跟着别人做。</p><h4 id="3-1-综合向"><a href="#3-1-综合向" class="headerlink" title="3.1 综合向"></a>3.1 综合向</h4><ol><li>严格保持规律作息</li><li>营造仪式感</li><li>说滥了的劳逸结合</li></ol><h4 id="3-2-公共课"><a href="#3-2-公共课" class="headerlink" title="3.2 公共课"></a>3.2 公共课</h4><h5 id="3-2-1-政治"><a href="#3-2-1-政治" class="headerlink" title="3.2.1 政治"></a>3.2.1 政治</h5><ol><li>最后的肖四 yyds ，但前期应当先把精讲精练反复多看，把选择题得分拉高</li><li>主观题不要迷信泛泛而谈的“大”模板</li></ol><h5 id="3-2-2-英语"><a href="#3-2-2-英语" class="headerlink" title="3.2.2 英语"></a>3.2.2 英语</h5><ol><li>坚持背单词</li><li>真题迟点再开始刷</li></ol><h4 id="3-3-专业课"><a href="#3-3-专业课" class="headerlink" title="3.3 专业课"></a>3.3 专业课</h4><ul><li>各院校交互设计专业考察内容不同，备考开始时最好先联系师兄师姐咨询他们的经验，包括参考书单、历年真题、学习笔记等内容，减少走弯路。</li><li>部分院校交互设计专业考题变化很大，注意总结真题题型变化趋势，严格按照官网给出的考试范围和参考书目备考。</li><li>真题留到最后两三个月定期严格按照考试时间和时长进行模拟考试，保持好手感。</li><li>看书做好笔记，建议使用软件做笔记，比手写笔记更容易回看、检索，应形成学科理论的思维导图 / 核心主干，便于最后冲刺复习。</li></ul><hr><blockquote><p>先写到这里好了，之后的内容再慢慢更新。</p><p> 真不错，这里就不会像公众号一样，发出去的东西没法大改。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>交互设计</tag>
      
      <tag>考研分享</tag>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
